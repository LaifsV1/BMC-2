Methods:
fact (arg:Int * (Int->Int)) :(Int) =
  let (n:Int)        = (fst:Int * (Int->Int)) arg in
  let (exn:Int->Int) = (snd:Int * (Int->Int)) arg in
  if n
  then
    let (f:Int->Int) = fun (i:Int) :(Int) -> if i then exn i else 1 in
    n * (fact (n + -1,f))
  else exn 0;

Main:(Int):
fact (2,(fun (x:Int) :(Int) -> fail))

(* points-to analysis would speed this up *)
